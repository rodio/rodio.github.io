<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Winit and WGPU</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; } /* Alert */
    code span.an { color: #008000; } /* Annotation */
    code span.at { } /* Attribute */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #0010ff; } /* ControlFlow */
    code span.ch { color: #008080; } /* Char */
    code span.cn { } /* Constant */
    code span.co { color: #008000; } /* Comment */
    code span.cv { color: #008000; } /* CommentVar */
    code span.do { color: #008000; } /* Documentation */
    code span.dt { color: #0010ff; font-style: italic; } /* DataType */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.im { } /* Import */
    code span.in { color: #008000; } /* Information */
    code span.kw { color: #962eff; } /* Keyword */
    code span.op { } /* Operator */
    code span.ot { color: #f54927; } /* Other */
    code span.pp { color: #8e8e8e; } /* Preprocessor */
    code span.sc { color: #008080; } /* SpecialChar */
    code span.ss { color: #008080; } /* SpecialString */
    code span.st { color: #008080; } /* String */
    code span.va { } /* Variable */
    code span.vs { color: #008080; } /* VerbatimString */
    code span.wa { color: #008000; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
<a href="../index.html" style="font-family: sans-serif;">← back</a>
<header id="title-block-header">
<h1 class="title">Winit and WGPU</h1>
</header>
<p><a href="https://docs.rs/winit/latest/winit/">winit</a> is a Rust
crate (library) that helps with creating windows on different operating
systems and platforms.</p>
<p><a href="https://wgpu.rs">wgpu</a> is a graphics library for Rust
based on the <a href="https://www.w3.org/TR/webgpu/">WebGPU API</a>.
Applications built with it can run natively on Vulkan, Metal, DirectX
12, OpenGL ES, and in browsers via WebAssembly.</p>
<p>You begin by creating a window using winit. To draw something on it,
you first need to create a wgpu surface.</p>
<p>This looks something like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> window <span class="op">=</span> winit_event_loop<span class="op">.</span>create_window(window_attributes)<span class="op">.</span>unwrap()<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> surface <span class="op">=</span> wgpu_instance<span class="op">.</span>create_surface(<span class="op">&amp;</span>window)<span class="op">.</span>unwrap()<span class="op">;</span></span></code></pre></div>
<p>By looking directly at wgpu’s <code>Cargo.toml</code> (where its
dependencies are declared) we can see that wgpu does not have winit as a
dependency. Likewise, winit does not “know” about wgpu either.</p>
<p><em>How is it possible that a method from one crate takes an instance
of a struct from another (seemingly unrelated) crate?</em></p>
<p>So, let’s have a look starting from wgpu’s perspective.</p>
<h2 id="part-one-surfacetarget">Part One:
<code>SurfaceTarget</code></h2>
<p>Since we’re feeding winit’s window to wgpu’s
<code>create_surface(...)</code>, this mystery would be solved, <em>if
we could see that <code>winit::Window</code> is somehow related to
<code>wgpu::SurfaceTarget</code>.</em></p>
<p>The signature of wgpu’s <code>create_surface(...)</code> method from
above is as follows:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">fn</span> create_surface<span class="op">&lt;</span><span class="ot">&#39;window</span><span class="op">&gt;</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">&amp;</span><span class="kw">self</span><span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    target<span class="op">:</span> <span class="kw">impl</span> <span class="bu">Into</span><span class="op">&lt;</span>SurfaceTarget<span class="op">&lt;</span><span class="ot">&#39;window</span><span class="op">&gt;&gt;,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span>Surface<span class="op">&lt;</span><span class="ot">&#39;window</span><span class="op">&gt;,</span> CreateSurfaceError<span class="op">&gt;</span> </span></code></pre></div>
<p>Even without knowing much about Rust—and ignoring the
<code>'window</code> <a
href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">lifetimes</a>—
it is hopefully intuitive that <code>create_surface(...)</code> takes
something that can be converted <code>Into</code>
<code>SurfaceTarget</code>. So one might expect to find an
implementation of this <code>Into</code> trait (i.e. interface) for a
winit <code>Window</code> (or <a
href="https://doc.rust-lang.org/rust-by-example/conversion/from_into.html">its
counterpart</a>, <code>From</code>), allowing us to convert the winit
window into <code>SurfaceTarget</code>.</p>
<p>But obviously, there’s no point in searching for something like
<code>impl From&lt;winit::Window&gt; for wgpu::SurfaceTarget</code> or
<code>impl Into&lt;wgpu::SurfaceTarget&gt; for winit::Window</code> in
any of these libraries’ codebases, because they don’t “know” about each
other.</p>
<p>Yet we can easily find this <a
href="https://doc.rust-lang.org/book/ch10-02-traits.html">blanket
implementation</a> in wgpu’s codebase:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="bu">From</span><span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="cf">for</span> SurfaceTarget<span class="op">&lt;</span><span class="ot">&#39;a</span><span class="op">&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    T<span class="op">:</span> WindowHandle <span class="op">+</span> <span class="ot">&#39;a</span><span class="op">,</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> from(window<span class="op">:</span> T) <span class="op">-&gt;</span> <span class="dt">Self</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// snip</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>It says that we can convert <em>from</em> anything that implements
something called <code>WindowHandle</code> <em>into</em>
<code>SurfaceTarget</code>. And because Rust implements
<code>Into</code> for us when it has <code>From</code>, anything that
implements <code>WindowHandle</code> can be converted <em>into</em>
surface target. So behind the scenes, there is
<code>impl&lt;T&gt; Into&lt;SurfaceTarget&gt; for T where T: WindowHandle</code>.</p>
<p>So we now can cut out the middleman—<code>SurfaceTarget</code>—and
our mystery would be solved <em>if we could see that
<code>winit::Window</code> is somehow related to
<code>wgpu::WindowHandle</code>.</em></p>
<h2 id="part-two-windowhandle">Part Two: <code>WindowHandle</code></h2>
<p>So what kind of thing is <code>wgpu::WindowHandle</code>? Let’s go to
its definition:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">/// Super trait for window handles as used in [`SurfaceTarget`].</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> WindowHandle<span class="op">:</span> HasWindowHandle <span class="op">+</span> HasDisplayHandle <span class="op">+</span> WasmNotSendSync <span class="op">{}</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> WindowHandle <span class="cf">for</span> T <span class="kw">where</span> T<span class="op">:</span> HasWindowHandle <span class="op">+</span> HasDisplayHandle <span class="op">+</span> WasmNotSendSync <span class="op">{}</span></span></code></pre></div>
<p>This blanket implementation means that any type can be treated as a
WindowHandle as long as it implements the three required traits. That’s
a big thing because while <code>WindowHandle</code> comes from the
<code>wgpu</code> create, <code>HasWindowHandle</code> is from another
crate called <code>raw_window_handle</code>.</p>
<p>Now the <code>raw_window_handle</code> crate seems to be the bridge
connecting these two crates (<code>winit</code> and <code>wgpu</code>)
and the key to solving this little mystery—since both crates include it
as a dependency in their Cargo.toml files.</p>
<p>We must now only verify that <code>winit</code>’s <code>Window</code>
implements <code>HasWindowHandle</code> and
<code>HasDisplayHandle</code> and <code>WasmNotSendSync</code></p>
<h2
id="part-three-haswindowhandle-hasdisplayhandle-wasmnotsendsync">Part
Three: <code>HasWindowHandle</code> + <code>HasDisplayHandle</code> +
<code>WasmNotSendSync</code></h2>
<p><code>HasWindowHandle</code> and <code>HasDisplayHandle</code> are
relatively straightforward to find in <code>winit</code>‘s
codebase’(<code>rwh_06</code> is an alias for raw_window_handle version
0.6):</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">rwh_06::</span>HasWindowHandle <span class="cf">for</span> Window <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> window_handle(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="pp">rwh_06::</span>WindowHandle<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">&gt;,</span> <span class="pp">rwh_06::</span>HandleError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>      <span class="co">// snip</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span> <span class="pp">rwh_06::</span>HasDisplayHandle <span class="cf">for</span> Window <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">fn</span> display_handle(<span class="op">&amp;</span><span class="kw">self</span>) <span class="op">-&gt;</span> <span class="dt">Result</span><span class="op">&lt;</span><span class="pp">rwh_06::</span>DisplayHandle<span class="op">&lt;</span><span class="ot">&#39;_</span><span class="op">&gt;,</span> <span class="pp">rwh_06::</span>HandleError<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">// snip</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>To examine the implementation for <code>WasmNotSendSync</code> we’re
going to need to go to go back to <code>wgpu</code>‘s codebase’ and
(ignoring the conditional compilation attributes for simplicity) there
we can find this blanket implementations:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 1:</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> WasmNotSendSync<span class="op">:</span> WasmNotSend <span class="op">+</span> WasmNotSync <span class="op">{}</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 2:</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">:</span> WasmNotSend <span class="op">+</span> WasmNotSync<span class="op">&gt;</span> WasmNotSendSync <span class="cf">for</span> T <span class="op">{}</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 3:</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> WasmNotSend <span class="op">{}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 4:</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> WasmNotSend <span class="cf">for</span> T <span class="op">{}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 5:</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">pub</span> <span class="kw">trait</span> WasmNotSync <span class="op">{}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="kw">impl</span><span class="op">&lt;</span>T<span class="op">&gt;</span> WasmNotSync <span class="cf">for</span> T <span class="op">{}</span></span></code></pre></div>
<p>So, we’ve got: 1. <code>WasmNotSendSync</code> is obviously
<code>WasmNotSend + WasmNotSync</code>. 2. Anything that implements
<code>WasmNotSend</code> and <code>WasmNotSync</code> automatically
implements <code>WasmNotSendSync</code> 3. <code>WasmNotSend</code> is
just a marker trait 4. Anything can be <code>WasmNotSend</code> since
there is this blanket implementation. 5. Anything can be
<code>WasmNotSync</code> for the same reasons.</p>
<p>Well, it seems like <strong>every type</strong> implements all these
three traits…</p>
<a href="../index.html" style="font-size: 1.5em; font-family: sans-serif;">← back</a>
</body>
</html>
